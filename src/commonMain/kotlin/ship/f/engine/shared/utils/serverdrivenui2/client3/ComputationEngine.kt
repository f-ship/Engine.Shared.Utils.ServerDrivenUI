package ship.f.engine.shared.utils.serverdrivenui2.client3

import kotlinx.coroutines.*
import kotlinx.datetime.Clock
import ship.f.engine.shared.utils.serverdrivenui2.config.action.models.ResetState2
import ship.f.engine.shared.utils.serverdrivenui2.config.meta.models.PopulatedSideEffectMeta2
import ship.f.engine.shared.utils.serverdrivenui2.config.meta.models.ZoneViewModel3
import ship.f.engine.shared.utils.serverdrivenui2.config.state.models.Id2.MetaId2
import ship.f.engine.shared.utils.serverdrivenui2.config.state.models.Id2.StateId2
import ship.f.engine.shared.utils.serverdrivenui2.config.state.models.computation.Condition3
import ship.f.engine.shared.utils.serverdrivenui2.config.state.models.computation.LiveValue3
import ship.f.engine.shared.utils.serverdrivenui2.config.state.models.computation.Ref3
import ship.f.engine.shared.utils.serverdrivenui2.config.state.models.computation.Ref3.VmRef3
import ship.f.engine.shared.utils.serverdrivenui2.config.state.models.computation.value.*
import ship.f.engine.shared.utils.serverdrivenui2.config.state.modifiers.ChildrenModifier2
import ship.f.engine.shared.utils.serverdrivenui2.ext.sduiLog
import ship.f.engine.shared.utils.serverdrivenui2.state.RefState2
import ship.f.engine.shared.utils.serverdrivenui2.state.State2
import ship.f.engine.shared.utils.serverdrivenui2.state.TextState2

class ComputationEngine(val client: Client3) {

    data class ZoneWrapper(
        val viewModel: ZoneViewModel3?,
        val state: State2,
    )

    data class ChildOrderWrapper(
        val order: IntValue,
        val state: State2,
    )

    data class FilterWrapper(
        val filter: BooleanValue,
        val state: State2,
    )

    data class JumpToWrapper(
        val jumpTo: BooleanValue,
        val state: State2,
        val viewModel: ZoneViewModel3,
    )

    data class JobWrapper(val stateId: StateId2, val refreshMillis: Int)

    data class Timer(val client: Client3) {
        val map = mutableMapOf<JobWrapper, Job>()
        fun add(state: State2, refreshMillis: Int) {
            val jobWrapper = JobWrapper(state.id, refreshMillis)
            if (map.containsKey(jobWrapper)) return
            client.update(state)
            map[jobWrapper] = createTimer(refreshMillis) {
                try {
                    val updatedState = client.get<State2>(state.id)
                    (updatedState as? ChildrenModifier2<*>)?.children?.forEach { child ->
                        if (!child.id.isAutoGenerated) client.update(client.get<State2>(child.id).reset())
                    }
                    client.update(updatedState.reset())
                    client.commit()
                } catch (e: Exception) {
                    client.emitSideEffect(
                        PopulatedSideEffectMeta2(
                            metaId = MetaId2("%SDUIError%", "Timer"),
                        )
                    )
                }
                true
            }
        }

        fun createTimer(intervalMillis: Int, stillRunning: suspend () -> Boolean): Job {
            val job = CoroutineScope(Dispatchers.Default).launch {
                var isActive = true
                while (isActive) {
                    delay(intervalMillis.toLong())
                    if (!stillRunning()) {
                        isActive = false
                        cancel()
                    }
                }
            }
            return job
        }
    }

    val start = Clock.System.now().epochSeconds.toInt()
    val debugSpeed = 1
    fun getNow(): Int = (Clock.System.now().epochSeconds.toInt() - start) * debugSpeed + Clock.System.now().epochSeconds.toInt()

    val timer = Timer(client)

    fun sort(liveValue2: LiveValue3, parent: ChildrenModifier2<*>): ChildrenModifier2<*> {
        try {
            if (liveValue2 !is LiveValue3.ReferenceableLiveValue3) {
                sduiLog("sort > expected ReferenceableLiveValue3 but got $liveValue2")
                return parent
            }

            val zoneWrappers = parent.children.mapNotNull { child ->
                child.metas.filterIsInstance<ZoneViewModel3>().firstOrNull()?.let { zvm -> ZoneWrapper(zvm, child) }
            }

            val values = zoneWrappers.map { zW ->
                when (liveValue2.ref) {
                    is VmRef3 -> ChildOrderWrapper(order = zW.viewModel!!.map[liveValue2.ref.property] as IntValue, state = zW.state)
                    is Ref3.StateRef3 -> {
                        sduiLog("sort > expected StateRef3 but got ${liveValue2.ref}")
                        return parent
                    }
                }
            }.sortedBy { it.order.value }

            val updatedChildren = values.map { it.state }
            val updatedParent = parent.c(children = updatedChildren)
            client.update(updatedParent)
            return updatedParent as ChildrenModifier2<*>
        } catch (e: Exception) {
            sduiLog("sort error > $e", e, tag = "sort")
            client.emitSideEffect(
                PopulatedSideEffectMeta2(
                    metaId = MetaId2("%SDUIError%", "sort"),
                )
            )
            return parent
        }
    }

    fun filter(value: SingleConditionalValue, parent: ChildrenModifier2<*>): ChildrenModifier2<*> {
        try {
            // TODO will need to replicate similar logic to other methods below and even above
            val zoneWrappers = parent.children.map { child ->
                if (child is RefState2) {
                    val updatedChild = client.get<State2>(child.id)
                    updatedChild.metas.filterIsInstance<ZoneViewModel3>().firstOrNull().let { zvm -> ZoneWrapper(zvm, child) }
                } else {
                    child.metas.filterIsInstance<ZoneViewModel3>().firstOrNull().let { zvm -> ZoneWrapper(zvm, child) }
                }
            }

            val values = zoneWrappers.map { zW ->
                if (zW.viewModel == null) return@map FilterWrapper(BooleanValue(true), zW.state)
                val value = computeConditionalValue(value, zW.viewModel, parent as? State2)
                if (value !is BooleanValue) error("Expected boolean value but got $value")
                FilterWrapper(value, zW.state)
            }

            val updatedChildren = values.filter { it.filter.value }.map { it.state }
            val updatedParent = parent.modifiedChildren(modifiedChildren = updatedChildren)
            client.update(updatedParent)
            return updatedParent as ChildrenModifier2<*>
        } catch (e: Exception) {
            sduiLog("filter error > $e", e, tag = "filter")
            client.emitSideEffect(
                PopulatedSideEffectMeta2(
                    metaId = MetaId2("%SDUIError%", "filter"),
                )
            )
            return parent
        }
    }

    fun filterAll(allConditionValue: AllConditionalValue, parent: ChildrenModifier2<*>): ChildrenModifier2<*> {
        try {
            val zoneWrappers = parent.children.map { child ->
                child.metas.filterIsInstance<ZoneViewModel3>().firstOrNull().let { zvm -> ZoneWrapper(zvm, child) }
            }

            val values = zoneWrappers.map { zW ->
                if (zW.viewModel == null) return@map FilterWrapper(BooleanValue(true), zW.state)
                val bools = allConditionValue.values.map { single -> computeConditionalValue(single, zW.viewModel, parent as? State2) }
                val onlyBools = bools.filterIsInstance<BooleanValue>()
                if (bools.size != onlyBools.size) error("Expected only boolean values but got $bools")
                val value = BooleanValue(onlyBools.all { it.value })
                FilterWrapper(value, zW.state)
            }

            val updatedChildren = values.filter { it.filter.value }.map { it.state }
            val updatedParent = parent.modifiedChildren(modifiedChildren = updatedChildren)
            client.update(updatedParent)
            return updatedParent as ChildrenModifier2<*>
        } catch (e: Exception) {
            sduiLog("filterAll error > $e", e, tag = "filterAll")
            client.emitSideEffect(
                PopulatedSideEffectMeta2(
                    metaId = MetaId2("%SDUIError%", "filtering"),
                )
            )
            return parent
        }
    }

    fun index(parent: ChildrenModifier2<*>) {
        try {
            val children = parent.filteredChildren ?: parent.children
            children.forEachIndexed { index, child ->
                child.metas.filterIsInstance<ZoneViewModel3>().firstOrNull()?.let {
                    if (it.map["!index"] == IntValue(index)) return@forEachIndexed
                    it.map["!index"] = IntValue(index)
                }
            }
        } catch (e: Exception) {
            sduiLog("index error > $e", e, tag = "index")
            client.emitSideEffect(
                PopulatedSideEffectMeta2(
                    metaId = MetaId2("%SDUIError%", "index"),
                )
            )
        }
    }

    fun focus(parent: ChildrenModifier2<*>) {
        try {
            parent.children.forEach { child ->
                child.metas.filterIsInstance<ZoneViewModel3>().firstOrNull()?.let {
                    parent.focus?.let { focus ->
                        sduiLog("focus > parent focus: $focus", tag = "timer")
                        if (it.map["!focus"] == focus) return@forEach
                        it.map["!focus"] = focus
                    }
                }
            }
        } catch (e: Exception) {
            sduiLog("focus error > $e", e, tag = "focus")
            client.emitSideEffect(
                PopulatedSideEffectMeta2(
                    metaId = MetaId2("%SDUIError%", "focus"),
                )
            )
        }
    }

    fun jumpTo(liveValue: SingleConditionalValue, parent: ChildrenModifier2<*>): ChildrenModifier2<*> {
        try {
            val zoneWrappers = parent.children.mapNotNull { child ->
                child.metas.filterIsInstance<ZoneViewModel3>().firstOrNull()?.let { zvm -> ZoneWrapper(zvm, child) }
            }

            val values = zoneWrappers.map { zW ->
                val value = computeConditionalValue(liveValue, zW.viewModel, parent as? State2)
                if (value !is BooleanValue) error("Expected boolean value but got $value")
                JumpToWrapper(value, zW.state, zW.viewModel ?: error("Expected zone view model but got null in JumpToWrapper"))
            }

            val value = values.firstOrNull { it.jumpTo.value }
            val map = value?.viewModel?.map
            val newFocus = map?.get("!index") as? IntValue
            val updatedParent = parent.focus(newFocus)
            client.update(updatedParent)
            return updatedParent as ChildrenModifier2<*>
        } catch (e: Exception) {
            sduiLog("jumpTo error > $e", e, tag = "jumpTo")
            client.emitSideEffect(
                PopulatedSideEffectMeta2(
                    metaId = MetaId2("%SDUIError%", "jump"),
                )
            )
        }
        return parent
    }

    fun getValue(liveValue: LiveValue3, vm: ZoneViewModel3? = null, state2: State2? = null): Value {
        try {
            return when (liveValue) {
                is LiveValue3.ReferenceableLiveValue3 -> when (liveValue.ref) {
                    is Ref3.StateRef3 -> {
                        val paths = client.idPaths[liveValue.ref.id] ?: error("No paths found for id: ${liveValue.ref.id}")
                        val path = paths.firstOrNull() ?: error("Paths were empty for id: ${liveValue.ref.id}")
                        val state = client.get<State2>(path)
                        (state as? TextState2)?.text?.let { StringValue(it) }
                            ?: error("Not a text state ${liveValue.ref.id}")
                    }

                    is VmRef3 -> {
                        val updatedRef = if (liveValue.ref.vm == MetaId2() && vm != null) {
                            liveValue.copyRef(VmRef3(vm = vm.metaId, property = liveValue.ref.property)).ref
                        } else {
                            state2?.also {
                                client.addRemoteAction(
                                    metaId = liveValue.ref.vm,
                                    stateId = it.id,
                                    action = ResetState2(it.id),
                                )
                            }
                            liveValue.ref
                        } as VmRef3
                        client.get<ZoneViewModel3>(updatedRef.vm).map[updatedRef.property]
                            ?: error("No value found for ref > in getValue: $updatedRef in ${updatedRef.vm} for ${updatedRef.property}")
                    }
                }
                // TODO Could make it it's own type in future
                is LiveValue3.InstantNowLiveValue3 -> IntValue(getNow()).also {
                    if (state2 != null && !state2.id.isAutoGenerated && liveValue.refreshMillis != null) {
                        timer.add(state2, liveValue.refreshMillis / debugSpeed)
                    }
                }
                is LiveValue3.StaticLiveValue3 -> liveValue.value
            }
        } catch (e: Exception) {
            sduiLog("getValue error > $e", e, tag = "getValue")
            client.emitSideEffect(
                PopulatedSideEffectMeta2(
                    metaId = MetaId2("%SDUIError%", "evaluation"),
                )
            )
            return VoidValue(true)
        }
    }

    fun reduceValue(value: Value, vm: ZoneViewModel3? = null, state2: State2? = null): Value {
        try {
            return when (value) {
                is SingleConditionalValue -> computeConditionalValue(value, vm, state2)
                else -> value
            }
        } catch (e: Exception) {
            sduiLog("reduceValue error > $e", e, tag = "reduction")
            client.emitSideEffect(
                PopulatedSideEffectMeta2(
                    metaId = MetaId2("%SDUIError%", "evaluation"),
                )
            )
            return VoidValue(true)
        }
    }

    fun computeConditionalValue(value: SingleConditionalValue, vm: ZoneViewModel3? = null, state2: State2? = null): Value {
        try {
            val value1 = getValue(value.value1, vm, state2).run { reduceValue(this, vm, state2) }
            val value2 = getValue(value.value2, vm, state2).run { reduceValue(this, vm, state2) }

            val result = when (value.condition) {
                Condition3.All -> {
                    if (value1 !is ListValue<*>) value.notCurrentlySupported()
                    BooleanValue(value1.value.all { it == value2 })
                }

                Condition3.Eq -> {
                    BooleanValue(value1 == value2)
                }
                Condition3.GreaterThan -> {
                    when {
                        value1 is IntValue && value2 is IntValue -> BooleanValue(value1.value > value2.value)
                        else -> value.notCurrentlySupported()
                    }
                }

                Condition3.In -> {
                    if (value2 !is ListValue<*>) value.notCurrentlySupported()
                    BooleanValue(value1 in value2.value)
                }

                Condition3.InOrEmpty -> {
                    if (value2 !is ListValue<*>) value.notCurrentlySupported()
                    BooleanValue(value1 in value2.value || value2.value.isEmpty())
                }

                Condition3.LessThan -> {
                    when {
                        value1 is IntValue && value2 is IntValue -> BooleanValue(value1.value < value2.value)
                        else -> value.notCurrentlySupported()
                    }
                }

                Condition3.Mod -> {
                    when {
                        value1 is IntValue && value2 is IntValue -> BooleanValue((value1.value % value2.value) == 0)
                        else -> value.notCurrentlySupported()
                    }
                }

                Condition3.And -> {
                    when {
                        value1 is BooleanValue && value2 is BooleanValue -> BooleanValue(value1.value && value2.value)
                        else -> value.notCurrentlySupported()
                    }
                }

                else -> value.notCurrentlySupported()
            }

            val value = if (result.value) {
                getValue(value.trueBranch, vm)
            } else {
                getValue(value.falseBranch, vm)
            }

            return when(value) {
                is SingleConditionalValue -> computeConditionalValue(value, vm, state2)
                else -> value
            }
        } catch (e: Exception) {
            sduiLog("computeConditionalValue error > $e", e, tag = "computeConditionalValue")
            client.emitSideEffect(
                PopulatedSideEffectMeta2(
                    metaId = MetaId2("%SDUIError%", "evaluation"),
                )
            )
            return VoidValue(true)
        }
    }

    fun clear() {
        timer.map.forEach { (_, job) -> job.cancel() }
        timer.map.clear()
    }

    fun SingleConditionalValue.notCurrentlySupported(): Nothing =
        error("Not currently supported > $value1 $condition $value2")
}